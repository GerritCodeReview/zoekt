{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "315bf9dc_5319cd10",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-26T13:44:17Z",
      "side": 1,
      "message": "btw, great idea, and impressive numbers!",
      "revId": "1cc351eb320054a6e1831d182ba598ee2d3544ff",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac2ef9bc_fd5cb60d",
        "filename": "matchtree.go",
        "patchSetId": 2
      },
      "lineNbr": 387,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-26T13:44:06Z",
      "side": 1,
      "message": "You\u0027re treating the first one different, but isn\u0027t that another place to do a performance optimization?\n\nI\u0027d expect it to work like this:\n\n* Pick the child with the least number of matches.\n\n* For each match, calculate the start/end rune range of the line it is in, generating a list of start/end ranges. (they\u0027ll be sorted)\n\n* for remaining children, iterate over their matches, trimming the list of start/end ranges, if you can\u0027t find a    match in that line.\n\nThat would save on the lineNumber() function which seems relatively expensive, due to sort.Search and the findOffset() calls.",
      "range": {
        "startLine": 387,
        "startChar": 17,
        "endLine": 387,
        "endChar": 25
      },
      "revId": "1cc351eb320054a6e1831d182ba598ee2d3544ff",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "762e4414_d0733eaa",
        "filename": "matchtree.go",
        "patchSetId": 2
      },
      "lineNbr": 387,
      "author": {
        "id": 1060017
      },
      "writtenOn": "2020-10-27T13:59:57Z",
      "side": 1,
      "message": "I agree with the above. You should be able to avoid the use of maps and instead rely on sorted ranges.",
      "parentUuid": "ac2ef9bc_fd5cb60d",
      "range": {
        "startLine": 387,
        "startChar": 17,
        "endLine": 387,
        "endChar": 25
      },
      "revId": "1cc351eb320054a6e1831d182ba598ee2d3544ff",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b848a408_ba68b365",
        "filename": "matchtree.go",
        "patchSetId": 2
      },
      "lineNbr": 388,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-26T13:44:06Z",
      "side": 1,
      "message": "prealloc the map size.",
      "range": {
        "startLine": 388,
        "startChar": 22,
        "endLine": 388,
        "endChar": 25
      },
      "revId": "1cc351eb320054a6e1831d182ba598ee2d3544ff",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "59c48063_d90756d5",
        "filename": "matchtree.go",
        "patchSetId": 2
      },
      "lineNbr": 388,
      "author": {
        "id": 1118410
      },
      "writtenOn": "2020-10-28T12:45:48Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b848a408_ba68b365",
      "range": {
        "startLine": 388,
        "startChar": 22,
        "endLine": 388,
        "endChar": 25
      },
      "revId": "1cc351eb320054a6e1831d182ba598ee2d3544ff",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38f70dbf_78693f21",
        "filename": "query/query.go",
        "patchSetId": 2
      },
      "lineNbr": 180,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-26T13:44:06Z",
      "side": 1,
      "message": "nit: SingleLine ? having \u0027no\u0027 as part of a boolean name is hard to read.\n\nI wonder if this is the right representation.\n\nWouldn\u0027t it be more flexible if you could limit a general query to a single line?\n\nMaybe something like \n\n  (abc or def line:yes)\n\nwe could represent this as \u0026SingleLine{\u0026Or{ .. }}\n\n(see how the case:yes operator is implemented for parsing tips).",
      "range": {
        "startLine": 180,
        "startChar": 1,
        "endLine": 180,
        "endChar": 10
      },
      "revId": "1cc351eb320054a6e1831d182ba598ee2d3544ff",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e4304aa_a6a0659f",
        "filename": "query/query.go",
        "patchSetId": 2
      },
      "lineNbr": 180,
      "author": {
        "id": 1060017
      },
      "writtenOn": "2020-10-27T13:59:57Z",
      "side": 1,
      "message": "Alternatively not expose this in the `query` package, and instead make this an implementation detail of `matchtree`. If I am not mistaken we only need this when creating the matchtree from a regexp. Could we not keep this bit of information there?\n\nIt may require moving some stuff around, since the Regexp -\u003e SubStr logic lives in this package. However, it is only used by MatchTree, so that is a candidate to also move into matchtree specific logic.\n\nIf we do want to keep it in query, I agree with Han-Wen and we should extend the language to support this to make it first class. It requires a bit more work since your matchtree implementation will likely need to be more general. So rather than directly accessing `substrMatchTree.current` you will need to use `visitMatches` like is done in `gatherMatches`.",
      "parentUuid": "38f70dbf_78693f21",
      "range": {
        "startLine": 180,
        "startChar": 1,
        "endLine": 180,
        "endChar": 10
      },
      "revId": "1cc351eb320054a6e1831d182ba598ee2d3544ff",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba762a3f_f82d8d3f",
        "filename": "query/query.go",
        "patchSetId": 2
      },
      "lineNbr": 180,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2020-10-28T09:54:30Z",
      "side": 1,
      "message": "ping? \n\nI prefer Keegan\u0027s suggestion. It has the advantage that it doesn\u0027t change any publicly visible APIs, which is in line with this being a performance optimization.",
      "parentUuid": "5e4304aa_a6a0659f",
      "range": {
        "startLine": 180,
        "startChar": 1,
        "endLine": 180,
        "endChar": 10
      },
      "revId": "1cc351eb320054a6e1831d182ba598ee2d3544ff",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b6c8b265_25efef96",
        "filename": "query/query.go",
        "patchSetId": 2
      },
      "lineNbr": 180,
      "author": {
        "id": 1118410
      },
      "writtenOn": "2020-10-28T12:45:48Z",
      "side": 1,
      "message": "Keegan and I talked about how not to expose this change to the query package. There is a minor complication because `RegexpToQuery` calls `Simplify` which is called in other places too. We think the best way forward is to just copy\u0026paste `Simplify` from the query package to `matchtree.go`. Both `RegexToQuery` and the new `Simplify` would be private. In the future, we could even optimise the new `Simplify` for matchtrees if we wanted to.",
      "parentUuid": "ba762a3f_f82d8d3f",
      "range": {
        "startLine": 180,
        "startChar": 1,
        "endLine": 180,
        "endChar": 10
      },
      "revId": "1cc351eb320054a6e1831d182ba598ee2d3544ff",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d3ab21e4_be7fda7b",
        "filename": "query/regexp.go",
        "patchSetId": 2
      },
      "lineNbr": 65,
      "author": {
        "id": 1060017
      },
      "writtenOn": "2020-10-27T13:59:57Z",
      "side": 1,
      "message": "you need to check newline is not in Pattern",
      "revId": "1cc351eb320054a6e1831d182ba598ee2d3544ff",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153"
    }
  ]
}